<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Gradient BBCode Generator</title>
  <meta name="description" content="Generate per-character multi-color gradient BBCode for XenForo." />
  <style>
    :root{
      --bg: #0b0f19;
      --panel: rgba(255,255,255,.06);
      --panel2: rgba(255,255,255,.09);
      --text: rgba(255,255,255,.9);
      --muted: rgba(255,255,255,.65);
      --line: rgba(255,255,255,.12);
      --danger: #ff4d6d;
      --ok: #7ae582;
      --focus: rgba(133,185,255,.35);

      --radius: 18px;
      --shadow: 0 10px 35px rgba(0,0,0,.35);

      --ctrl-h: 40px;
      --ctrl-r: 14px;
      --ctrl-px: 12px;

      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    }

    *{ box-sizing:border-box; }
    body{
      margin:0;
      font-family: var(--sans);
      background:
        radial-gradient(1200px 800px at 20% 10%, rgba(133,185,255,.18), transparent 55%),
        radial-gradient(900px 700px at 80% 40%, rgba(208,100,255,.16), transparent 55%),
        radial-gradient(900px 700px at 60% 110%, rgba(122,229,130,.10), transparent 55%),
        var(--bg);
      color: var(--text);
      min-height:100vh;
      display:flex;
      align-items:center;
      justify-content:center;
      padding: 28px 14px;
    }

    .wrap{
      width: min(1100px, 100%);
      display:grid;
      gap: 16px;
    }

    header.site{
      padding: 6px 6px 2px;
    }
    h1{
      margin:0;
      font-size: 20px;
      letter-spacing: .2px;
      font-weight: 650;
    }

    .grid{
      display:grid;
      grid-template-columns: 1.05fr .95fr;
      gap: 16px;
    }
    @media (max-width: 920px){
      .grid{ grid-template-columns: 1fr; }
    }

    .card{
      background: var(--panel);
      border: 1px solid var(--line);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      overflow:hidden;
    }
    .card .head{
      padding: 16px 16px 10px;
      border-bottom: 1px solid var(--line);
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap: 12px;
      flex-wrap:wrap;
    }
    .card .head .title{
      font-size: 14px;
      color: rgba(255,255,255,.85);
      font-weight: 600;
    }
    .card .body{
      padding: 16px;
      display:grid;
      gap: 14px;
    }

    /* Text areas */
    textarea{
      width: 100%;
      min-height: 170px;
      resize: vertical;
      border-radius: 14px;
      border: 1px solid var(--line);
      background: rgba(0,0,0,.18);
      color: var(--text);
      padding: 12px 12px;
      outline:none;
      line-height: 1.35;
      font-size: 14px;
    }
    textarea:focus{ box-shadow: 0 0 0 4px var(--focus); }

    pre.output{
      margin:0;
      padding: 12px;
      border-radius: 14px;
      border: 1px solid var(--line);
      background: rgba(0,0,0,.22);
      overflow:auto;
      white-space: pre-wrap;
      word-break: break-word;
      font-family: var(--mono);
      font-size: 12.5px;
      line-height: 1.35;
      color: rgba(255,255,255,.88);
      min-height: 170px;
    }
    pre.output:empty::before{
      content: "BBCode will appear here…";
      color: rgba(255,255,255,.55);
    }

    .preview{
      padding: 12px;
      border-radius: 14px;
      border: 1px solid var(--line);
      background: rgba(0,0,0,.14);
      min-height: 84px;
      display:flex;
      flex-wrap:wrap;
      gap: 0;
      align-items:flex-start;
      align-content:flex-start;
      font-size: 16px;
      line-height: 1.4;
    }
    .preview .ch{ white-space: pre; }

    /* Layout helpers */
    .row{
      display:flex;
      gap: 10px;
      flex-wrap:wrap;
      align-items:center;
    }
    .status{
      display:flex;
      align-items:center;
      gap: 10px;
      flex-wrap:wrap;
    }

    /* Unified control sizing */
    .btn, .toggle, .pill, .badge{
      height: var(--ctrl-h);
      border-radius: var(--ctrl-r);
      display:inline-flex;
      align-items:center;
      gap: 10px;
      padding: 0 var(--ctrl-px);
      border: 1px solid var(--line);
      background: rgba(0,0,0,.16);
      color: var(--text);
      user-select:none;
      white-space:nowrap;
    }

    .btn{
      cursor:pointer;
      font-size: 13px;
      font-weight: 600;
      transition: transform .05s ease, background .15s ease, border-color .15s ease;
      background: rgba(255,255,255,.08);
    }
    .btn:hover{ background: rgba(255,255,255,.12); }
    .btn:active{ transform: translateY(1px); }
    .btn.primary{
      background: rgba(133,185,255,.20);
      border-color: rgba(133,185,255,.35);
    }
    .btn.primary:hover{ background: rgba(133,185,255,.26); }
    .btn.ghost{ background: rgba(0,0,0,.10); }

    .badge{
      font-family: var(--mono);
      font-size: 12px;
      color: rgba(255,255,255,.75);
      background: rgba(0,0,0,.14);
    }
    .badge.ok{
      border-color: rgba(122,229,130,.35);
      background: rgba(122,229,130,.10);
      color: rgba(122,229,130,.95);
    }
    .badge.warn{
      border-color: rgba(255,77,109,.35);
      background: rgba(255,77,109,.10);
      color: rgba(255,77,109,.95);
    }

    .label{
      color: var(--muted);
      font-size: 12px;
      margin-right: 2px;
    }

    /* Toggle (checkbox + label) */
    .toggle{
      cursor:pointer;
      background: rgba(0,0,0,.16);
    }
    .toggle input{
      margin:0;
      transform: scale(1.05);
    }
    .toggle span{
      font-size: 13px;
      color: rgba(255,255,255,.85);
    }

    /* Format select pill: make the dropdown match the rest of the UI */
    .pill.select{
      position: relative;
      padding-right: 34px; /* room for chevron */
    }
    .pill.select::after{
      content: "▾";
      position:absolute;
      right: 12px;
      top: 50%;
      transform: translateY(-50%);
      font-size: 12px;
      color: rgba(255,255,255,.65);
      pointer-events:none;
    }
    .pill:focus-within{
      box-shadow: 0 0 0 4px var(--focus);
      border-color: rgba(133,185,255,.35);
    }
    select.format{
      appearance: none;
      -webkit-appearance: none;
      -moz-appearance: none;
      border: none;
      background: transparent;
      color: var(--text);
      padding: 0;
      outline: none;
      font-family: var(--mono);
      font-size: 13px;
    }

    
    /* Pretty dropdown menu (replaces the native select popup) */
    .pill.select.dropdown{ position: relative; cursor: pointer; }

    .format-btn{
      border: none;
      background: transparent;
      color: var(--text);
      padding: 0;
      margin: 0;
      outline: none;
      cursor: pointer;
      font-family: var(--mono);
      font-size: 13px;
      line-height: 1;

      /* Make the whole pill easier to click: button grows to fill the pill */
      flex: 1 1 auto;
      min-width: 0;
      height: 100%;
      display: inline-flex;
      align-items: center;
    }
    .format-btn:focus{ outline: none; }

    .format-menu{
      position: absolute;
      top: calc(100% + 10px);
      left: 0;
      min-width: 180px;
      padding: 8px;
      border-radius: 14px;
      border: 1px solid var(--line);
      background: rgba(18, 22, 34, .98);
      box-shadow: var(--shadow);
      z-index: 50;
      transform: translateY(-2px);
      opacity: 0;
      pointer-events: none;
      transition: opacity .12s ease, transform .12s ease;
    }
    .pill.select.dropdown.open .format-menu{
      opacity: 1;
      transform: translateY(0);
      pointer-events: auto;
    }
    .pill.select.dropdown.open::after{
      transform: translateY(-50%) rotate(180deg);
      color: rgba(255,255,255,.78);
    }

    .format-opt{
      width: 100%;
      height: 36px;
      border-radius: 12px;
      border: 1px solid transparent;
      background: transparent;
      color: rgba(255,255,255,.88);
      font-family: var(--mono);
      font-size: 13px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      padding: 0 10px;
      cursor:pointer;
    }
    .format-opt:hover{ background: rgba(255,255,255,.08); }
    .format-opt:focus{
      outline:none;
      box-shadow: 0 0 0 4px var(--focus);
      border-color: rgba(133,185,255,.35);
    }
    .format-opt[aria-selected="true"]{
      background: rgba(133,185,255,.18);
      border-color: rgba(133,185,255,.30);
      color: rgba(255,255,255,.95);
    }
    .format-opt[aria-selected="true"]::after{
      content: "✓";
      color: rgba(133,185,255,.95);
      font-weight: 800;
    }

    /* Drag & drop reorder for stops */
    body.dragging{ user-select: none; }

    .stop .drag-handle{
      cursor: grab;
      touch-action: none;
    }
    .stop .drag-handle:active{ cursor: grabbing; }

    .stop.dragging{
      opacity: .92;
      border-color: rgba(133,185,255,.35);
      background: rgba(0,0,0,.22);
      box-shadow: 0 18px 50px rgba(0,0,0,.55);
    }
    .stop.placeholder{
      border-style: dashed;
      background: rgba(0,0,0,.06);
    }


    /* Stops list */
    .stops{
      display:grid;
      gap: 10px;
    }
    .stop{
      display:flex;
      gap: 10px;
      align-items:center;
      flex-wrap:wrap;
      padding: 10px 12px;
      border-radius: 14px;
      border: 1px solid var(--line);
      background: rgba(0,0,0,.12);
    }
    .stop .spacer{ flex: 1 1 auto; min-width: 8px; }
    .stop .name{
      color: rgba(255,255,255,.82);
      font-size: 12px;
      font-family: var(--mono);
      opacity:.9;
    }

    input[type="color"]{
      width: 44px;
      height: 32px;
      border-radius: 12px;
      border: 1px solid var(--line);
      background: rgba(0,0,0,.16);
      padding: 0;
      cursor:pointer;
      overflow:hidden;
    }
    input[type="color"]::-webkit-color-swatch-wrapper{ padding: 0; }
    input[type="color"]::-webkit-color-swatch{
      border: none;
      border-radius: 10px;
    }

    input[type="text"].hex{
      width: 120px;
      height: 32px;
      border-radius: 12px;
      border: 1px solid var(--line);
      background: rgba(0,0,0,.16);
      color: var(--text);
      padding: 0 10px;
      outline:none;
      font-family: var(--mono);
      font-size: 13px;
    }
    input[type="text"].hex:focus{ box-shadow: 0 0 0 4px var(--focus); }
    input[type="text"].hex.invalid{
      border-color: rgba(255,77,109,.55);
      box-shadow: none;
    }

    .btn.icon{
      height: 34px;
      border-radius: 12px;
      padding: 0 10px;
      font-family: var(--mono);
      font-weight: 750;
      line-height: 1;
    }

    .meta{
      display:flex;
      justify-content:flex-end;
      color: var(--muted);
      font-size: 12px;
    }

    /* Accessibility helper */
    .sr-only{
      position:absolute;
      width:1px;
      height:1px;
      padding:0;
      margin:-1px;
      overflow:hidden;
      clip:rect(0,0,0,0);
      white-space:nowrap;
      border:0;
    }

    /* Small screens */
    @media (max-width: 520px){
      input[type="text"].hex{ width: 104px; }
      .stop{ gap: 8px; }
    }

    /* Toast */
    .toast{
      position: fixed;
      left: 50%;
      bottom: 18px;
      transform: translateX(-50%);
      background: rgba(0,0,0,.55);
      border: 1px solid rgba(255,255,255,.14);
      border-radius: 999px;
      padding: 10px 14px;
      font-size: 13px;
      color: rgba(255,255,255,.92);
      box-shadow: 0 10px 28px rgba(0,0,0,.35);
      opacity: 0;
      pointer-events: none;
      transition: opacity .15s ease, transform .15s ease;
    }
    .toast.show{
      opacity: 1;
      transform: translateX(-50%) translateY(-2px);
    }

    @media (prefers-reduced-motion: reduce){
      .btn{ transition:none; }
      .toast{ transition:none; }
    }
  </style>
</head>

<body>
  <div class="wrap">
    <header class="site">
      <h1>Gradient BBCode Generator</h1>
    </header>

    <main class="grid">
      <!-- Left: Input -->
      <section class="card">
        <div class="head">
          <div class="title">Input</div>
          <div class="status">
            <span id="limitBadge" class="badge">Output: 0 / 600</span>
            <button class="btn primary" id="copyBtn" type="button">Copy BBCode</button>
          </div>
        </div>

        <div class="body">
          <textarea id="textInput" placeholder="Type or paste your text here…" aria-label="Text input"></textarea>

          <div class="row">
            <div class="pill select" title="Choose the BBCode color format">
              <span class="label">Format</span>
              <select id="formatSelect" class="format" aria-label="Output format">
                <option value="hex" selected>HEX (XenForo)</option>
                <option value="rgb">RGB</option>
              </select>
            </div>

            <label class="toggle" title="Include spaces in the gradient (spaces will be colored too)">
              <input id="includeSpaces" type="checkbox" />
              <span>Color spaces</span>
            </label>

            <label class="toggle" title="Escape [ and ] so your text won't accidentally break BBCode">
              <input id="escapeBrackets" type="checkbox" checked />
              <span>Escape [ ]</span>
            </label>

            <button class="btn ghost" id="clearBtn" type="button">Clear</button>
          </div>

          <div class="row" style="align-items:flex-start; justify-content:space-between;">
            <div style="min-width:240px; flex: 1 1 520px;">
              <div class="label" style="margin-bottom:8px;">Colors</div>
              <div id="stops" class="stops"></div>

              <div class="row" style="justify-content:flex-start; margin-top:10px;">
                <button class="btn" id="addStopBtn" type="button">Add color</button>
                <button class="btn ghost" id="reverseBtn" type="button" title="Reverse color order">Reverse order</button>
                <button class="btn" id="rainbowBtn" type="button" title="Replace colors with a smooth rainbow gradient">Rainbow-fy</button>
              </div>
            </div>

            <div class="meta" style="flex: 0 0 auto; align-items:flex-start;">
              <div class="status" style="justify-content:flex-end;">
                <span class="badge" id="charCount">Chars: 0</span>
                <span class="badge" id="coloredCount">Colored: 0</span>
                <span class="badge" id="bbCount">BBCode len: 0</span>
                <span class="badge" id="maxAdd">Can add: 0</span>
              </div>
            </div>
          </div>
        </div>
      </section>

      <!-- Right: Preview + Output -->
      <section class="card">
        <div class="head">
          <div class="title">Preview & Output</div>
        </div>

        <div class="body">
          <div class="sr-only" id="previewLabel">Preview</div>
          <div id="preview" class="preview" aria-labelledby="previewLabel"></div>

          <div class="sr-only" id="outputLabel">BBCode output</div>
          <pre id="output" class="output" aria-labelledby="outputLabel"></pre>
        </div>
      </section>
    </main>
  </div>

  <div id="toast" class="toast" role="status" aria-live="polite"></div>

<script>
(() => {
  "use strict";

  const LIMIT = 600;

  const els = {
    textInput: document.getElementById("textInput"),
    formatSelect: document.getElementById("formatSelect"),
    includeSpaces: document.getElementById("includeSpaces"),
    escapeBrackets: document.getElementById("escapeBrackets"),
    stops: document.getElementById("stops"),
    addStopBtn: document.getElementById("addStopBtn"),
    reverseBtn: document.getElementById("reverseBtn"),
    rainbowBtn: document.getElementById("rainbowBtn"),
    output: document.getElementById("output"),
    preview: document.getElementById("preview"),
    copyBtn: document.getElementById("copyBtn"),
    clearBtn: document.getElementById("clearBtn"),
    limitBadge: document.getElementById("limitBadge"),
    charCount: document.getElementById("charCount"),
    coloredCount: document.getElementById("coloredCount"),
    bbCount: document.getElementById("bbCount"),
    maxAdd: document.getElementById("maxAdd"),
    toast: document.getElementById("toast"),
  };

  let toastTimer = null;
  function showToast(msg){
    if (!els.toast) return;
    els.toast.textContent = msg;
    els.toast.classList.add("show");
    clearTimeout(toastTimer);
    toastTimer = setTimeout(() => els.toast.classList.remove("show"), 900);
  }

  function setupFormatDropdown(){
    const select = els.formatSelect;
    if (!select) return;

    const host = select.closest(".pill.select");
    if (!host) return;

    // Avoid double init
    if (host.querySelector(".format-btn")) return;

    host.classList.add("dropdown");
    // Keep the real <select> for accessibility, but hide it visually
    select.classList.add("sr-only");
    select.setAttribute("aria-hidden", "true");
    select.tabIndex = -1;

    const btn = document.createElement("button");
    btn.type = "button";
    btn.className = "format-btn";
    btn.setAttribute("aria-haspopup", "listbox");
    btn.setAttribute("aria-expanded", "false");

    const menu = document.createElement("div");
    menu.className = "format-menu";
    menu.setAttribute("role", "listbox");
    menu.setAttribute("aria-label", "Output format");
    menu.setAttribute("aria-hidden", "true");

    const optionBtns = [];
    [...select.options].forEach((opt) => {
      const b = document.createElement("button");
      b.type = "button";
      b.className = "format-opt";
      b.setAttribute("role", "option");
      b.dataset.value = opt.value;
      b.textContent = opt.textContent;
      optionBtns.push(b);
      menu.appendChild(b);
    });

    function isOpen(){ return host.classList.contains("open"); }

    function syncFromSelect(){
      btn.textContent = select.options[select.selectedIndex]?.textContent || "Format";
      optionBtns.forEach((b) => {
        const sel = b.dataset.value === select.value;
        b.setAttribute("aria-selected", sel ? "true" : "false");
        // Prevent focusing hidden options when the menu is closed
        b.tabIndex = isOpen() ? (sel ? 0 : -1) : -1;
      });
    }

    function openMenu(){
      host.classList.add("open");
      btn.setAttribute("aria-expanded", "true");
      menu.setAttribute("aria-hidden", "false");
      syncFromSelect();
      (optionBtns.find(b => b.dataset.value === select.value) || optionBtns[0])?.focus();
    }

    function closeMenu({ focusButton = true } = {}){
      host.classList.remove("open");
      btn.setAttribute("aria-expanded", "false");
      menu.setAttribute("aria-hidden", "true");
      // When closed, ensure options aren't tabbable
      optionBtns.forEach(b => b.tabIndex = -1);

      if (focusButton){
        btn.focus({ preventScroll: true });
      } else if (menu.contains(document.activeElement)) {
        // Avoid leaving focus on hidden menu options
        document.activeElement.blur();
      }
    }

    btn.addEventListener("click", (e) => {
      e.preventDefault();
      e.stopPropagation();
      if (isOpen()) closeMenu({ focusButton: false });
      else openMenu();
    });

    // Make the entire pill clickable (label/empty space/chevron area),
    // not just the button text.
    host.addEventListener("click", (e) => {
      if (e.target.closest(".format-menu")) return;
      if (e.target.closest(".format-btn")) return; // button handles itself
      if (isOpen()) closeMenu({ focusButton: false });
      else openMenu();
    });

    btn.addEventListener("keydown", (e) => {
      if (e.key === "ArrowDown" || e.key === "Enter" || e.key === " "){
        e.preventDefault();
        openMenu();
      }
    });

    menu.addEventListener("click", (e) => {
      e.stopPropagation();
      const b = e.target.closest(".format-opt");
      if (!b) return;
      const val = b.dataset.value;
      if (val){
        select.value = val;
        select.dispatchEvent(new Event("change", { bubbles: true }));
      }
      closeMenu();
    });

    menu.addEventListener("keydown", (e) => {
      const current = document.activeElement;
      const idx = optionBtns.indexOf(current);
      if (e.key === "Escape"){
        e.preventDefault();
        closeMenu();
      } else if (e.key === "ArrowDown"){
        e.preventDefault();
        optionBtns[Math.min(optionBtns.length - 1, Math.max(0, idx) + 1)]?.focus();
      } else if (e.key === "ArrowUp"){
        e.preventDefault();
        optionBtns[Math.max(0, Math.max(0, idx) - 1)]?.focus();
      } else if (e.key === "Home"){
        e.preventDefault();
        optionBtns[0]?.focus();
      } else if (e.key === "End"){
        e.preventDefault();
        optionBtns[optionBtns.length - 1]?.focus();
      } else if (e.key === "Enter" || e.key === " "){
        e.preventDefault();
        if (current && current.classList.contains("format-opt")) current.click();
      }
    });

    // Close when clicking outside
    document.addEventListener("pointerdown", (e) => {
      if (!isOpen()) return;
      if (!host.contains(e.target)) closeMenu({ focusButton: false });
    });

    // Keep in sync if assistive tech changes the real <select>
    select.addEventListener("change", syncFromSelect);

    syncFromSelect();
    host.appendChild(btn);
    host.appendChild(menu);
  }

  function setupStopDragAndDrop(){
    let state = null;

    function listItems(){
      return [...els.stops.querySelectorAll(".stop:not(.dragging):not(.placeholder)")];
    }

    function getAfterElement(y){
      let closest = { offset: Number.NEGATIVE_INFINITY, element: null };
      for (const el of listItems()){
        const box = el.getBoundingClientRect();
        const offset = y - (box.top + box.height / 2);
        if (offset < 0 && offset > closest.offset){
          closest = { offset, element: el };
        }
      }
      return closest.element;
    }

    function cleanup(commit){
      if (!state) return;

      const { item, placeholder } = state;

      window.removeEventListener("pointermove", onMove);
      window.removeEventListener("pointerup", onUp);
      window.removeEventListener("pointercancel", onUp);

      if (commit){
        els.stops.insertBefore(item, placeholder);
      }
      placeholder.remove();

      item.classList.remove("dragging");
      item.style.position = "";
      item.style.left = "";
      item.style.top = "";
      item.style.width = "";
      item.style.zIndex = "";
      item.style.pointerEvents = "";

      document.body.classList.remove("dragging");

      state = null;
      renumberStops();
      update();
    }

    function onMove(e){
      if (!state || e.pointerId !== state.pointerId) return;
      state.item.style.top = (e.clientY - state.offsetY) + "px";

      const after = getAfterElement(e.clientY);
      if (!after) els.stops.appendChild(state.placeholder);
      else els.stops.insertBefore(state.placeholder, after);
    }

    function onUp(e){
      if (!state || e.pointerId !== state.pointerId) return;
      cleanup(true);
    }

    els.stops.addEventListener("pointerdown", (e) => {
      const handle = e.target.closest(".drag-handle");
      if (!handle) return;

      const item = handle.closest(".stop");
      if (!item) return;

      // Primary button only (left click / touch)
      if (e.button !== undefined && e.button !== 0) return;

      // Don't start another drag while one is active
      if (state) return;

      e.preventDefault();

      const rect = item.getBoundingClientRect();
      const placeholder = document.createElement("div");
      placeholder.className = "stop placeholder";
      placeholder.style.height = rect.height + "px";
      placeholder.setAttribute("aria-hidden", "true");

      // Put placeholder right where the item was
      els.stops.insertBefore(placeholder, item.nextSibling);

      item.classList.add("dragging");
      document.body.classList.add("dragging");

      item.style.position = "fixed";
      item.style.left = rect.left + "px";
      item.style.top = rect.top + "px";
      item.style.width = rect.width + "px";
      item.style.zIndex = "9999";
      item.style.pointerEvents = "none";

      state = {
        pointerId: e.pointerId,
        item,
        placeholder,
        offsetY: e.clientY - rect.top,
      };

      window.addEventListener("pointermove", onMove);
      window.addEventListener("pointerup", onUp);
      window.addEventListener("pointercancel", onUp);
    });
  }

  function clamp01(x){ return Math.max(0, Math.min(1, x)); }

  function normalizeHex(input){
    let s = (input || "").trim();
    if (!s) return null;
    if (s[0] !== "#") s = "#" + s;
    if (!/^#([0-9a-fA-F]{3}|[0-9a-fA-F]{6})$/.test(s)) return null;
    if (s.length === 4){
      s = "#" + [...s.slice(1)].map(ch => ch + ch).join("");
    }
    return s.toUpperCase();
  }

  function hexToRgb(hex){
    const h = normalizeHex(hex);
    if (!h) return null;
    const r = parseInt(h.slice(1,3), 16);
    const g = parseInt(h.slice(3,5), 16);
    const b = parseInt(h.slice(5,7), 16);
    return { r, g, b };
  }

  function rgbToHex(c){
    return "#" + [c.r, c.g, c.b].map(x => x.toString(16).padStart(2,"0")).join("").toUpperCase();
  }

  function lerp(a,b,t){ return a + (b - a) * t; }
  function lerpRgb(c1, c2, t){
    return {
      r: Math.round(lerp(c1.r, c2.r, t)),
      g: Math.round(lerp(c1.g, c2.g, t)),
      b: Math.round(lerp(c1.b, c2.b, t)),
    };
  }

  // Rainbow helpers
  function hslToRgb(h, s, l){
    h = ((h % 360) + 360) % 360;
    s = clamp01(s / 100);
    l = clamp01(l / 100);

    const c = (1 - Math.abs(2*l - 1)) * s;
    const hh = h / 60;
    const x = c * (1 - Math.abs((hh % 2) - 1));

    let r1 = 0, g1 = 0, b1 = 0;
    if (hh >= 0 && hh < 1){ r1 = c; g1 = x; b1 = 0; }
    else if (hh >= 1 && hh < 2){ r1 = x; g1 = c; b1 = 0; }
    else if (hh >= 2 && hh < 3){ r1 = 0; g1 = c; b1 = x; }
    else if (hh >= 3 && hh < 4){ r1 = 0; g1 = x; b1 = c; }
    else if (hh >= 4 && hh < 5){ r1 = x; g1 = 0; b1 = c; }
    else { r1 = c; g1 = 0; b1 = x; }

    const m = l - c / 2;
    return {
      r: Math.round((r1 + m) * 255),
      g: Math.round((g1 + m) * 255),
      b: Math.round((b1 + m) * 255),
    };
  }

  function makeRainbowHexStops(count){
    const H0 = 0;
    const H1 = 300;
    const S = 100;
    const L = 55;

    const n = Math.max(2, Math.floor(count || 0));
    const out = [];
    for (let i = 0; i < n; i++){
      const t = n === 1 ? 0 : i / (n - 1);
      const h = lerp(H0, H1, t);
      out.push(rgbToHex(hslToRgb(h, S, L)));
    }
    return out;
  }

  function countGradientTargets(text, includeSpaces){
    const chars = [...(text || "")];
    let n = 0;
    for (let i = 0; i < chars.length; i++){
      if (includeSpaces || !/\s/.test(chars[i])) n++;
    }
    return n;
  }

  function replaceStops(hexes){
    els.stops.innerHTML = "";
    (hexes || []).forEach(h => addStop(h));
    update();
  }

  function rainbowFy(){
    const text = els.textInput.value || "";
    const includeSpaces = els.includeSpaces.checked;
    const N = countGradientTargets(text, includeSpaces);

    const MAX_STOPS = 24;
    const stopCount = N > 0 ? Math.min(MAX_STOPS, Math.max(2, N)) : 7;
    replaceStops(makeRainbowHexStops(stopCount));
  }

  function escapeForBBCodeChar(ch){
    if (ch === "[") return "&#91;";
    if (ch === "]") return "&#93;";
    return ch;
  }

  function getStops(){
    const nodes = [...els.stops.querySelectorAll(".stop:not(.placeholder)")];
    const stops = nodes.map(n => {
      const hexEl = n.querySelector('input[type="text"].hex');
      const typed = normalizeHex(hexEl.value);
      const fallback = normalizeHex(hexEl.dataset.lastValid || "");
      return typed || fallback;
    }).filter(Boolean);
    return stops;
  }

  function addStop(hex){
    const safe = normalizeHex(hex) || "#85B9FF";
    const idx = els.stops.children.length + 1;

    const div = document.createElement("div");
    div.className = "stop";
    div.innerHTML = `
      <button class="btn icon drag-handle" type="button" title="Drag to reorder" aria-label="Drag to reorder">⠿</button>
      <span class="name">Stop ${idx}</span>
      <input type="color" value="${safe}" aria-label="Color picker"/>
      <input type="text" class="hex" value="${safe}" spellcheck="false" aria-label="Hex color"/>
      <span class="spacer"></span>
      <button class="btn icon" type="button" title="Move up" aria-label="Move up">↑</button>
      <button class="btn icon" type="button" title="Move down" aria-label="Move down">↓</button>
      <button class="btn icon" type="button" title="Remove" aria-label="Remove">✕</button>
    `;

    const color = div.querySelector('input[type="color"]');
    const hexIn = div.querySelector('input[type="text"].hex');
    const upBtn = div.querySelector('button[aria-label="Move up"]');
    const downBtn = div.querySelector('button[aria-label="Move down"]');
    const rmBtn = div.querySelector('button[aria-label="Remove"]');

    hexIn.dataset.lastValid = safe;

    function syncFromColor(){
      const v = color.value.toUpperCase();
      hexIn.value = v;
      hexIn.dataset.lastValid = v;
      hexIn.classList.remove("invalid");
      update();
    }
    function syncFromHex(){
      const h = normalizeHex(hexIn.value);
      if (h){
        color.value = h;
        hexIn.value = h;
        hexIn.dataset.lastValid = h;
        hexIn.classList.remove("invalid");
      } else {
        hexIn.classList.add("invalid");
      }
      update();
    }

    color.addEventListener("input", syncFromColor);
    hexIn.addEventListener("input", syncFromHex);

    upBtn.addEventListener("click", () => {
      const prev = div.previousElementSibling;
      if (prev) els.stops.insertBefore(div, prev);
      renumberStops();
      update();
    });

    downBtn.addEventListener("click", () => {
      const next = div.nextElementSibling;
      if (next) els.stops.insertBefore(next, div);
      renumberStops();
      update();
    });

    rmBtn.addEventListener("click", () => {
      div.remove();
      renumberStops();
      update();
    });

    els.stops.appendChild(div);
    renumberStops();
  }

  function renumberStops(){
    [...els.stops.querySelectorAll(".stop .name")].forEach((el, i) => {
      el.textContent = `Stop ${i+1}`;
    });
  }

  function reverseStops(){
    const items = [...els.stops.children];
    items.reverse().forEach(n => els.stops.appendChild(n));
    renumberStops();
  }

  function buildGradient(text, stopHexes, includeSpaces, escapeBrackets, format){
    const chars = [...text];
    if (chars.length === 0) return { bbcode: "", coloredN: 0 };

    const stops = stopHexes.map(hexToRgb).filter(Boolean);
    if (stops.length < 2){
      return { bbcode: "Add at least 2 valid colors.", coloredN: 0 };
    }

    const targets = [];
    for (let i = 0; i < chars.length; i++){
      if (includeSpaces || !/\s/.test(chars[i])) targets.push(i);
    }
    if (targets.length === 0){
      const raw = escapeBrackets ? chars.map(escapeForBBCodeChar).join("") : text;
      return { bbcode: raw, coloredN: 0 };
    }

    const N = targets.length;
    const parts = chars.slice();

    for (let k = 0; k < N; k++){
      const idx = targets[k];
      const globalT = N === 1 ? 0 : k / (N - 1);

      const segFloat = globalT * (stops.length - 1);
      const seg = Math.min(stops.length - 2, Math.max(0, Math.floor(segFloat)));
      const localT = segFloat - seg;

      const c = lerpRgb(stops[seg], stops[seg+1], clamp01(localT));
      const rawCh = parts[idx];
      const ch = escapeBrackets ? escapeForBBCodeChar(rawCh) : rawCh;

      if (format === "rgb"){
        parts[idx] = `[COLOR=rgb(${c.r}, ${c.g}, ${c.b})]${ch}[/COLOR]`;
      } else {
        parts[idx] = `[COLOR=${rgbToHex(c)}]${ch}[/COLOR]`;
      }
    }

    // Escape brackets in uncolored chars too (like spaces)
    if (escapeBrackets){
      for (let i = 0; i < parts.length; i++){
        if (typeof parts[i] === "string" && !parts[i].startsWith("[COLOR=")){
          parts[i] = parts[i].replaceAll("[", "&#91;").replaceAll("]", "&#93;");
        }
      }
    }

    return { bbcode: parts.join(""), coloredN: N };
  }

  function renderPreview(text, stopHexes, includeSpaces){
    const chars = [...text];
    els.preview.innerHTML = "";

    if (!chars.length){
      els.preview.innerHTML = `<span style="color: rgba(255,255,255,.55)">Preview will appear here…</span>`;
      return;
    }

    const stops = stopHexes.map(hexToRgb).filter(Boolean);
    if (stops.length < 2){
      els.preview.innerHTML = `<span style="color: rgba(255,255,255,.65)">Add at least 2 valid colors.</span>`;
      return;
    }

    const targets = [];
    for (let i = 0; i < chars.length; i++){
      if (includeSpaces || !/\s/.test(chars[i])) targets.push(i);
    }
    const N = targets.length;

    const idxToK = new Map();
    targets.forEach((idx, k) => idxToK.set(idx, k));

    for (let i = 0; i < chars.length; i++){
      const span = document.createElement("span");
      span.className = "ch";
      span.textContent = chars[i];

      const k = idxToK.get(i);
      if (k !== undefined && N > 0){
        const globalT = N === 1 ? 0 : k / (N - 1);
        const segFloat = globalT * (stops.length - 1);
        const seg = Math.min(stops.length - 2, Math.max(0, Math.floor(segFloat)));
        const localT = segFloat - seg;
        const c = lerpRgb(stops[seg], stops[seg+1], clamp01(localT));
        span.style.color = `rgb(${c.r}, ${c.g}, ${c.b})`;
      } else {
        span.style.color = "rgba(255,255,255,.85)";
      }

      els.preview.appendChild(span);
    }
  }

  function estimateCanAdd(baseText, stopHexes, includeSpaces, escapeBrackets, format, baseOutLen){
    // Upper bound is small because LIMIT is small. Keep this fast and predictable.
    if (baseOutLen > LIMIT) return 0;

    const MAX_TRY = 120; // plenty (hex max is ~25 chars before 600)
    let lo = 0, hi = MAX_TRY;

    while (lo < hi){
      const mid = Math.ceil((lo + hi) / 2);
      const t = baseText + "a".repeat(mid);
      const { bbcode } = buildGradient(t, stopHexes, includeSpaces, escapeBrackets, format);
      const L = (bbcode || "").length;
      if (L <= LIMIT) lo = mid;
      else hi = mid - 1;
    }
    return lo;
  }

  function update(){
    const text = els.textInput.value || "";
    const stopHexes = getStops();
    const includeSpaces = els.includeSpaces.checked;
    const escapeBrackets = els.escapeBrackets.checked;
    const format = els.formatSelect.value;

    els.charCount.textContent = `Chars: ${[...text].length}`;

    const { bbcode, coloredN } = buildGradient(text, stopHexes, includeSpaces, escapeBrackets, format);
    const out = bbcode || "";

    els.output.textContent = out;
    els.coloredCount.textContent = `Colored: ${coloredN}`;
    els.bbCount.textContent = `BBCode len: ${out.length}`;
    els.limitBadge.textContent = `Output: ${out.length} / ${LIMIT}`;
    els.limitBadge.className = "badge " + (out.length > LIMIT ? "warn" : "ok");

    renderPreview(text, stopHexes, includeSpaces);

    const canAdd = estimateCanAdd(text, stopHexes, includeSpaces, escapeBrackets, format, out.length);
    els.maxAdd.textContent = `Can add: ${canAdd}`;

    // Disable copy when there's nothing meaningful to copy
    els.copyBtn.disabled = out.length === 0;
    els.copyBtn.style.opacity = out.length === 0 ? "0.55" : "1";
  }

  async function copyOutput(){
    const text = els.output.textContent || "";
    if (!text) return;

    try{
      await navigator.clipboard.writeText(text);
      const old = els.copyBtn.textContent;
      els.copyBtn.textContent = "Copied ✓";
      showToast("Copied BBCode");
      setTimeout(() => { els.copyBtn.textContent = old; }, 900);
    } catch (e){
      const range = document.createRange();
      range.selectNodeContents(els.output);
      const sel = window.getSelection();
      sel.removeAllRanges();
      sel.addRange(range);
      alert("Clipboard permission blocked. Output selected — press Ctrl+C / Cmd+C to copy.");
    }
  }

  function clearAll(){
    els.textInput.value = "";
    update();
    els.textInput.focus();
  }

    // Enhance UI
  setupFormatDropdown();
  setupStopDragAndDrop();

// Events
  els.textInput.addEventListener("input", update);
  els.formatSelect.addEventListener("change", update);
  els.includeSpaces.addEventListener("change", update);
  els.escapeBrackets.addEventListener("change", update);
  els.copyBtn.addEventListener("click", copyOutput);
  els.clearBtn.addEventListener("click", clearAll);
  els.addStopBtn.addEventListener("click", () => { addStop("#FFFFFF"); update(); });
  els.reverseBtn.addEventListener("click", () => { reverseStops(); update(); });
  if (els.rainbowBtn) els.rainbowBtn.addEventListener("click", rainbowFy);

  // Init with 3 stops for "more than 2 colors"
  addStop("#85B9FF");
  addStop("#B59CFF");
  addStop("#D064FF");
  update();
})();
</script>
</body>
</html>
